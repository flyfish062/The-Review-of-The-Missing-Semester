> 关于shell在脚本与基础数据处理等方面的一些拓展

## 变量
```Bash

 正确：'=' 两侧没有空格
foo=bar

 错误：Shell会尝试执行名为'foo'的命令
foo = bar

echo $foo
```
### 命令与变量结合

变量不仅可以存字符串，还可以存**命令的运行结果**。
```Bash
#把 date 命令的输出结果，存入 current_time 变量
current_time=$(date)
echo "现在的时间是：$current_time"
echo "现在的时间是：$(date)"
```

## 引号

| 引号类型      | 核心行为与最佳使用场景                                                       |
| --------- | ----------------------------------------------------------------- |
| 双引号 (" ") | **会进行变量扩展和命令替换**。当需要在字符串中嵌入变量的值或命令的输出时，应使用双引号。                    |
| 单引号 (' ') | **会保留所有字符的字面值**。它会阻止任何形式的扩展，将内部所有内容都视为纯文本。当需要确保字符串内容不被Shell解释时使用。 |

总结而言，选择哪种引号取决于您的意图：若需动态插入值，请用双引号；若需保持字符串原样，请用单引号。

## 封装脚本/函数

```Bash
#先封装写好一个sh结尾的脚本
mcd()
{
  mkdir $1
  cd $1
}
#退出脚本编辑
：wq

#source命令可以让shell加载此脚本
source mcd

mcd a

#结果
当前目录中出现一个文件夹名为a
```

## 指定脚本的运行解释器

`#！`**必须**出现在脚本文件的**第一行**,告诉系统，用哪个“解释器”来执行这个脚本

当（`chmod +x script.sh`）并直接运行（`./script.sh`）时，Linux 会先读文件的第一行：

- 如果看到了 `#!`，它就会加载后面指定的程序来翻译代码。
- 如果没看到 `#!`，它通常会默认用当前的 Shell（比如 Bash）来尝试运行，但这对于 Python 脚本来说就会报错。

- **硬路径**：`#!/usr/bin/python3`
    
    - **缺点**：如果换了一台电脑，它的 Python 安装在 `/usr/local/bin/python3`，脚本就跑不起来了，找不到文件。
        
- **软路径**：`#!/usr/bin/env python3`(强力推荐)
    
    - **原理**：`env` 是一个系统命令，它的作用是“在系统的 `PATH` 变量里找 python3 在哪”。
    - **优点**：无论 Python 装在哪里，只要它配置好了环境变量，脚本都能跑。这就叫**可移植性**。


## 相关占位符

```Bash
./myscript.sh  apple  banana
```

| **符号**   | **含义**              | **对应上面的例子**                 |
| -------- | ------------------- | --------------------------- |
| **`$0`** | **脚本本身的名字**         | `./myscript.sh`(你输入什么他就是什么) |
| **`$1`** | **第 1 个参数**         | `apple`                     |
| **`$2`** | **第 2 个参数**         | `banana`                    |
| **`$#`** | **参数的个数** (Count)   | `2` (因为有两个参数)               |
| **`$@`** | **展开所有参数列表**        | `apple banana` (常用于遍历)      |
| **`$?`** | **上个命令的退出状态**       | `0` 或 `1` (你刚才问过的)          |
| **`$$`** | **当前进程的 ID** (PID)  | 比如 `12345` (用于生成临时文件名)      |
| **`$_`** | **扩展为上一条命令的最后一个参数** | `banana`                    |

## 历史指示符

| **符号**          | **含义**                   | **场景示例**                                           |
| --------------- | ------------------------ | -------------------------------------------------- |
| **`!!`**        | **上一条命令**                | `sudo !!` (以管理员身份重跑上一条)                            |
| **`!n`**        | **执行历史记录中的第 n 条**        | `!105` (执行 `history` 列表中编号为 105 的命令)               |
| **`!-n`**       | **执行倒数第 n 条命令**          | `!-2` (执行倒数第二条命令)                                  |
| **`!string`**   | **执行最近一条以 string 开头的命令** | `!vim` (自动寻找最近一次运行的 vim 命令并执行)                     |
| **`!?string?`** | **执行最近一条包含 string 的命令**  | `!?conf?` (寻找最近一次包含 "conf" 的命令)                    |
| **`^old^new`**  | **把上一条命令里的 old 替换为 new** | 刚输入了 `cat file.txt`，输入 `^txt^md` 会变成 `cat file.md` |
| **`history`**   | **显示你所输入过的全部命令**         |                                                    |

## 错误处理与控制流

### 退出码
当一个命令执行完毕，它都会返回一个**退出码**，这是一个整数，用于表示命令的执行状态。

• **退出码** **0**：代表命令**成功**执行。
• **任何非零退出码**（如 `1`, `2`, `127` 等）：代表命令执行**失败**

`true` 总是成功返回 `0`，而 `false` 总是失败返回 `1`。

### 逻辑操作符
`&&`  和 `||` ，它们可以基于前一个命令的退出码来决定是否执行下一个命令。这种行为被称为**短路求值**。

• **&&** ：只有当**左侧**命令成功（退出码为 `0`）时，才会执行**右侧**的命令。
• **||** ：只有当**左侧**命令失败（退出码为非 `0`）时，才会执行**右侧**的命令。

实例
```Bash
cd some_directory || exit 1
```

代码含义：尝试进入 `some_directory` 目录，如果失败（`cd` 命令返回非零退出码），则立即执行 `exit 1` 来终止整个脚本。

### 输出流

当只关心一个命令是否成功执行，而对其具体的输出内容（标准输出 `stdout` 和标准错误 `stderr`）不感兴趣时。在这种情况下，我们可以将这些输出重定向到`/dev/null`，它会丢弃所有写入它的数据。

```
# 将标准输出(>)和标准错误(2>&1)都重定向到/dev/null
grep "fubar" $file > /dev/null 2>&1
```

第一个`>`是标准输出流（拿到正确运行时的输出结果）
第二个`2>`是标准错误输出流（错误运行时的输出结果）
`&1`将展开为`>`后面的内容


```Bash
convert p1.png p1.jpg
#将p1转化为jpg格式
```

## 进程替换
**把一个命令的“输出”，伪装成一个“文件”

在 Linux 中，有一类命令（比如 `diff`、`comm`、`paste`、`vim`）**只接受文件名作为参数**，而不支持从标准输入读取数据，或者当需要同时输入**两个**文件流时，普通的管道（`|`） 不可用了。

- 比较两个目录里的文件列表，普通做法是：
    
    1. 把 `ls dir1` 的结果写入 `file1.txt`。
    2. 把 `ls dir2` 的结果写入 `file2.txt`。
    3. 运行 `diff file1.txt file2.txt`。
    4. 删掉这两个临时文件。
        
- **解决方案**：使用进程替换，一行命令搞定，且**不需要创建实体临时文件**。

```Bash
diff <(ls dir1) <(ls dir2)
```

## 通配符与正则表达式

- **通配符 (Wildcards)**：给 Shell 用的（`ls`, `cp`, `rm`）。
- **正则表达式 (Regex)**：给文本处理工具用的（`grep`, `awk`, `sed`, `vim`）。


### 通配符

| **符号**                     | **含义**  | **匹配规则**                | **示例命令**                                     | **解释**                                                             |
| -------------------------- | ------- | ----------------------- | -------------------------------------------- | ------------------------------------------------------------------ |
| **`*`**                    | **星号**  | 匹配 **0 个或无数个** 任意字符     | `rm *.jpg`                                   | 删除当前目录下所有后缀为 `.jpg` 的文件。                                           |
| **`?`**                    | **问号**  | 匹配 **1 个** 任意字符 (必须占位)  | `ls doc?.txt`                                | 匹配 `doc1.txt`, `docA.txt`；<br><br> **不**匹配 `doc10.txt` (因为它有2个字符)。 |
| **`[...]`**                | **方括号** | 匹配括号内 **指定范围中的 1 个** 字符 | `ls file[0-9].txt`                           | 匹配 `file1.txt` 到 `file9.txt`；<br><br>**不**匹配 `fileA.txt`           |
| **`[!...]`**<br>或 `[^...]` | **取反**  | 匹配 **不在** 括号内的 1 个字符    | `ls [!a]*.txt`                               | 列出所有 **不以 a 开头** 的 `.txt` 文件。                                      |
| **`{...}`**                | **花括号** | **生成序列** (非匹配，而是扩展字符串)  | `touch {a,b}.txt`   `{1，2}{1...3}`会展开为2*3个式子 | 等同于输入 `touch a.txt b.txt`，创建这两个文件。<br>                             |


## 推荐工具

### shellcheck
告诉你编写的shell脚本哪里有错误，方便错误处理
```Bash
ls -l
#表格形式列文件

mv -i
#移除文件时提醒

man
#说明书
```

### `tldr` 

 **"Too Long; Didn't Read"**（太长不看）。

`tldr` 只给你看**最常用、最实用的例子**。它是一个**社区维护的命令速查表**。

- **`man`** ：全而深，适合查生僻细节。
- **`tldr`** ：简而精，适合快速干活。

### 查找方法(find)

```Bash
find [在哪里找] [找什么] [找到后做什么]
```

|**维度**|**参数**|**含义**|**常用示例**|
|---|---|---|---|
|**名字**|`-name`|精确文件名 (区分大小写)|`find . -name "*.cpp"` (找 cpp 文件)|
||`-iname`|**忽略**大小写|`find . -iname "readme.md"` (找 README, ReadMe...)|
|**类型**|`-type f`|只找**文件** (File)|`find . -type f -name "run"` (找名为 run 的文件)|
||`-type d`|只找**目录** (Directory)|`find . -type d -name "src"` (找 src 文件夹)|
|**时间**|`-mtime`|修改时间 (天)|`find . -mtime -7` (最近 7 天内修改的)|
|**大小**|`-size`|文件大小|`find . -size +100M` (大于 100MB)|
|**深度**|`-maxdepth`|限制搜索层级|`find . -maxdepth 1` (只在当前目录找，不进子文件夹)|


```Bash
# 找：是文件 AND 大于100M AND 是jpg图片
find . -type f -size +100M -name "*.jpg"
# 找：是 .jpg 或者 .png 
find . -name "*.jpg" -o -name "*.png"
# 找：所有不是 .o (编译中间件) 的文件 
find . -type f ! -name "*.o"
# 危险！直接删除找到的所有 .tmp 文件
 find . -name "*.tmp" -delete
 # 把找到的所有 .log 文件移动到 /tmp 目录
 find . -name "*.log" -exec mv {} /tmp/ \;
```

### locate

“查目录索引”**（查数据库，快但可能延迟）。

- **原理**：Linux 系统会定期（通常每天一次）把电脑里所有文件的位置记录到一个数据库文件（`mlocate.db`）。当你运行 `locate` 时，它直接去读这个数据库，而不是去遍历硬盘。
    
- **优点**：**秒出结果**。哪怕你要在几十万个文件里找东西，它也是瞬间完成。
- **缺点**：**非实时**。如果你刚新建了一个文件，立刻用 `locate` 找，是找不到的。
#### 语法

 ```Bash
 locate [参数] "文件名关键词"
 ```

| **参数**   | **含义** | **举例**                                        |
| -------- | ------ | --------------------------------------------- |
| **`-i`** | 忽略大小写  | 文件名是 `IoStream`，搜 `iostream` 也能找到             |
| **`-e`** | 只显存在   | 如果文件刚才被删了但数据库没更新，加这个参数就不会把它搜出来                |
| **`-r`** | 正则模式   | 使用正则表达式搜索。`locate -r "\.cpp$"` (只找 cpp 结尾的文件) |
| **`-c`** | 统计数量   | 不列出路径，只告诉我找到了几个文件。`locate -c stdio.h`         |
### `ripgrep(rp)`

它的作用和`grep` 一样，搜索。
特点
1. **快**：用 Rust 写的，速度比 `grep` 快。
 
2. **默认不读取**：它**默认**不会读取你的 `.gitignore` 文件。

3. **自动递归**、**自动忽略垃圾文件**

####  语法

 ```Bash
 rg "搜索内容"
 ```


**除了grip的五个常见参数，还有5个自己独特的参数**

|**参数**|**含义**|**场景举例**|
|---|---|---|
|**`-t`**|**t**ype (指定文件类型)|**只搜 C++ 文件**：`rg -t cpp "main"` (神器！)|
|**`-l`**|**l**ist (只显文件名)|不看具体代码，只想知道**哪些文件**里用到了这个函数|
|**`-C`**|**C**ontext (上下文)|显示匹配行 + **上下各 N 行** (调试时看逻辑用)|
|**`-F`**|**F**ixed string (纯文本)|即使搜 `(.)*` 这种特殊符号，也当作普通字符，不当正则处理|
|**`-u`**|**u**nrestricted (无视忽略)|**强行搜索**被 `.gitignore` 忽略的文件|

**实例**

在一个庞大的项目里搜 `main` 这个词：

- **用 `grep` (`grep -r "main" .`)**：
    
    - 它会搜 `.git` 隐藏目录。
        
    - 它会搜编译出来的二进制文件。
        
    - **结果**：垃圾信息多。
- **用 `ripgrep` (`rg "main"`)**：
    
    - 自动跳过 `.git`。
        
    - 自动跳过 `.gitignore` 里忽略的文件。
        
    - 自动跳过二进制文件。
        
    - **结果**：瞬间只显示你手写的源代码里的 `main`，而且自带颜色高亮，文件名和行号清清楚楚。

### grep

**过滤**。 给一段文本（或者一个文件），它把**符合条件的行**挑出来，剩下的扔掉。

相较于`ripgrep`具有
**普遍性**，**管道操作（接受上一个命令的结果）**

#### 基本语法

```Bash
grep [参数] "搜索内容" [文件或路径]
```

| **参数**   | **含义**    | **举例**                     |
| -------- | --------- | -------------------------- |
| **`-i`** | **忽略大小写** | 搜 "Error" 时也能把 "error" 找出来 |
| **`-v`** | **反选 **   | 显示**不包含**这个词的行             |
| **`-n`** | **显示行号**  | 显示这行代码在文件的第几行              |
| **`-r`** | **递归搜索**  | 搜整个文件夹里的所有文件               |
| **`-E`** | **增强正则**  | 支持更多正则符号 (比如 `             |
### `fzf`(模糊搜索)

任何**列表**（文件列表、命令历史、进程列表）变成一个**可以交互、可以模糊搜索的菜单**

实例
文件夹里有 1000 个文件。
- **普通做法**：`ls` 刷屏，然后你眯着眼睛找，或者用 `grep` 过滤。
    
- **fzf 做法**：运行 `ls | fzf`。
    
    - 终端瞬间变成一个全屏菜单。
    - 敲几个字母（比如 `cf`），它自动帮你匹配 `config.yaml` 或 `common_func.cpp`（模糊匹配，不需要字母挨着）。
    - 选中回车，文件名打印。



`fzf` 几乎从不单独使用，它永远接在别的命令后面：

Bash

```
输入源 | fzf | 对选中的结果做操作
```

| **参数**          | **含义**         | **场景举例**                             |
| --------------- | -------------- | ------------------------------------ |
| **`-m`**        | **m**ulti (多选) | 允许按 `Tab` 键选中多个文件，最后一起输出             |
| **`--preview`** | **预览神器**       | 选中文件时，右边弹出一个窗口显示内容 (最常用！)            |
| **`--height`**  | 高度限制           | `fzf --height 40%` (不占满全屏，只在下方占 40%) |
| **`--reverse`** | 反向布局           | 输入框在最上面                              |
| **`-q`**        | **q**uery (预填) | 启动时自动填好搜索词：`fzf -q "main"`           |
|                 |                |                                      |

#### 在`fzf`中搜索

| 符号          | **含义**   | **例子**  | **解释**              |     |
| ----------- | -------- | ------- | ------------------- | --- |
| **`'word`** | **精准匹配** | `'main` | 必须包含 "main" (不拆分字符) |     |
| **`^word`** | **前缀匹配** | `^src`  | 必须以 "src" 开头        |     |
| **`word$`** | **后缀匹配** | `.cpp$` | 必须以 ".cpp" 结尾       |     |
| **`!word`** | **反向匹配** | `!test` | **不要**包含 "test" 的   |     |
    **Ctrl + R (历史命令搜索)** 
- **以前**：按 `Ctrl+R` 只能显示最近的一条，而且记准关键词。
    
- **现在**：按 `Ctrl+R`，弹出一个巨大的列表，显示你输过的所有命令。。
    

  **Ctrl + T (文件查找)**

- **场景**：想用 vim 编辑藏得很深的一个文件。
    
- **操作**：输入 `vim` (注意有个空格)，然后按 **`Ctrl + T`**。
    
- **效果**：弹出一个全屏文件查找框。找到文件后回车，路径自动补全到命令行里。
    

 **Alt + C (快速进入目录)**

- **操作**：按 **`Alt + C`**。
    
- **效果**：搜索当前目录下的所有子目录，选中回车，直接 `cd` 进去。

### `tree`


```Bash
tree
```

它会递归打印当前目录下**所有**的文件和文件夹。 _(如果在根目录或文件极多的项目里直接敲 `tree`，屏幕会被刷爆)

 限制层级 (`-L`)
只想看顶层结构，不想看深层细节：

Bash

```
tree -L 1   # 只看第一层
tree -L 2   # 看两层
```

排除垃圾文件 (`-I`)

不想看 `node_modules` 或 `.git` 这种庞然大物：

Bash

```
tree -I "node_modules|.git"
```

_(注意：多个忽略项用 `|` 隔开，且建议加引号)_

 只看文件夹 (`-d`)

不关心具体文件，只想看目录架构：

Bash

```
tree -d
```
- **Tree**: 适合**展示**。比如生成静态文本发给别人看。
- **Broot**: 适合**交互**。比如自己在复杂的目录里找文件、跳转目录。

### `Broot`

Tree（可视化）+ Fzf（搜索）+ Cd（跳转）的结合体。

我这里只找到1.36.1版本可用，常见操作根据版本有改动，请参考内置帮助手册

| **按键**         | **作用**      | **备注**                   |
| -------------- | ----------- | ------------------------ |
| **`↓` / `↑`**  | **上下移动**    | 选择文件或目录                  |
| **`Esc`**      | **后退 / 清除** | 如果搜了字，先清除字；如果没搜字，返回上一级目录 |
| **`直接打字`**     | **搜索**      | 模糊匹配，不需要按 Ctrl+F，直接敲键盘即可 |
| **`Ctrl + c`** | **退出**      | 直接关闭程序，不做任何改变            |


| **按键**               | **作用**                                    | **关键场景**                        |
| -------------------- | ----------------------------------------- | ------------------------------- |
| **`Alt + Enter`**    | **进入目录 (cd)**(旧版控制台这个快捷键容易被占用，选择：cd 然后进入) | **最重要！** 选中文件夹按这个，终端会**真的跳转**进去 |
| **`Ctrl + e`**       | **打开 / 编辑**                               | 调用 Vim/Nano 编辑选中的文件             |
| **`Ctrl + →` (右箭头)** | **预览 / 展开**                               | 选中文件是预览内容；选中目录是展开下级             |
| **`Ctrl + ←` (左箭头)** | **关闭 / 折叠**                               | 关闭右侧预览窗口；或折叠当前目录                |
